// this code is autogenerated, do not check it into to your code repository

// ref lib/igh_ethercat/nif.ex:46
const std = @import("std");
const beam = @import("beam");
const root = @import("root");
const ecrt = @cImport(@cInclude("ecrt.h"));

pub const MasterResource = beam.Resource(*ecrt.ec_master_t, root, .{ .Callbacks = MasterResourceCallbacks });
pub const DomainResource = beam.Resource(*ecrt.ec_domain_t, root, .{});
pub const SlaveConfigResource = beam.Resource(*ecrt.ec_slave_config_t, root, .{});

pub const MasterResourceCallbacks = struct {
    pub fn dtor(s: **ecrt.ec_master_t) void {
        std.debug.print("dtor called: {}\n", .{s.*});
        ecrt.ecrt_release_master(s.*);
    }
};

const MasterError = error{
    MasterNotFound,
    ResetError,
    GetSlaveError,
    SlaveConfigError,
    ActivateError,
    PdoRegError,
    InvalidDomainData,
};

// this is needed since zig doesn't support bitfields. See https://github.com/ziglang/zig/issues/1499
const packed_ec_master_state_t = packed struct {
    slaves_responding: u32,
    al_states: u4,
    link_up: u1,
    padding: u27, // 27 bits to align to 64 bits (8 bytes)
};

// al_state_* turns true if at least one slave is in the specified state
const master_state_t = struct {
    slaves_responding: u32,
    al_state_init: u1,
    al_state_preop: u1,
    al_state_safeop: u1,
    al_state_op: u1,
    link_up: u1
};

const ec_slave_config_state_t = packed struct {
    online: u1,
    operational: u1,
    al_state: u4,
    padding: u2, // 2 bits to align to 8 bits (1 byte)
};

pub fn version_magic() !u32 {
    return ecrt.ecrt_version_magic();
}

pub fn request_master(index: u32) !MasterResource {
    const master = ecrt.ecrt_request_master(index) orelse return MasterError.MasterNotFound;
    return MasterResource.create(master, .{ .released = false });
}

pub fn master_activate(master: MasterResource) !void {
    const result = ecrt.ecrt_master_activate(master.unpack());
    if (result != 0) return MasterError.ActivateError;
}

pub fn master_receive(master: MasterResource) !void {
    _ = ecrt.ecrt_master_receive(master.unpack());
}

pub fn master_send(master: MasterResource) !void {
    _ = ecrt.ecrt_master_send(master.unpack());
}

pub fn get_master_state(master: MasterResource) !beam.term {
    const master_state: master_state_t = try do_get_master_state(master.unpack());
    return beam.make(master_state, .{});
}

fn do_get_master_state(master: *ecrt.ec_master_t) !master_state_t {
    var packed_state: packed_ec_master_state_t = undefined;
    const result = ecrt.ecrt_master_state(master, @ptrCast(&packed_state));
    if (result != 0) {
        return MasterError.MasterNotFound;
    }
    return master_state_t{
        .slaves_responding = packed_state.slaves_responding,
        .al_state_init = @truncate(packed_state.al_states >> 0),
        .al_state_preop = @truncate(packed_state.al_states >> 1),
        .al_state_safeop = @truncate(packed_state.al_states >> 2),
        .al_state_op = @truncate(packed_state.al_states >> 3),
        .link_up = packed_state.link_up,
    };
}

pub fn master_create_domain(master: MasterResource) !DomainResource {
    const domain = ecrt.ecrt_master_create_domain(master.unpack()) orelse return MasterError.MasterNotFound;
    return DomainResource.create(domain, .{});
}

pub fn master_slave_config(master: MasterResource, alias: u16, position: u16, vendor_id: u32, product_code: u32) !SlaveConfigResource {
    const slave_config = ecrt.ecrt_master_slave_config(master.unpack(), alias, position, vendor_id, product_code) orelse return MasterError.SlaveConfigError;
    std.debug.print("Slave Config: {}\n", .{slave_config});
    std.debug.print("Master: {}\n", .{master.unpack()});
    return SlaveConfigResource.create(slave_config, .{});
}

pub fn master_get_slave(master: MasterResource, slave_position: u16) !beam.term {
    var slave_info: ecrt.ec_slave_info_t = undefined;
    const result = ecrt.ecrt_master_get_slave(master.unpack(), slave_position, &slave_info);
    if (result != 0) {
        return MasterError.GetSlaveError;
    }
    return beam.make(.{ .ok, slave_info }, .{});
}

pub fn master_reset(master: MasterResource) !void {
    const result = ecrt.ecrt_master_reset(master.unpack());
    if (result != 0) {
        return MasterError.ResetError;
    }
}

pub fn release_master(master: MasterResource) !void {
    // TODO check if master.release needs to be called
    ecrt.ecrt_release_master(master.unpack());
    master.release();
    std.debug.print("Master released: {}\n", .{master.unpack()});
}

pub fn domain_process(domain: DomainResource) !void {
    _ = ecrt.ecrt_domain_process(domain.unpack());
}

pub fn domain_queue(domain: DomainResource) !void {
    _ = ecrt.ecrt_domain_queue(domain.unpack());
}

// since ecrt_domain_data just returns domain->process_data
// this should be managed inside zig.
// So there should be these functions
// get_domain_value(domain, offset, bit_position?)
// which returns the current value
// set_domain_value(domain, offset, bit_position?, value)
// which sets the value
// and subscribe_domain_value(domain, offset, bit_position?)
// which subscribes to changes of the value
pub fn domain_data(domain: DomainResource) ![*c]u8 {
    const result = ecrt.ecrt_domain_data(domain.unpack());
    return result;
}

// TODO add bit_position
pub fn get_domain_value(domain: DomainResource, offset: u32) u8 {
    const data = ecrt.ecrt_domain_data(domain.unpack());
    std.debug.print("Byte 0: {}, Byte 1: {}\n", .{ data[0], data[1] });
    return data[offset];
}

// TODO handle bit precise offset
pub fn set_domain_value(domain: DomainResource, offset: u32, value: []u8) !void {
    const target: [*]u8 = ecrt.ecrt_domain_data(domain.unpack());
    for (value, 0..) |byte, i| {
        target[i + offset] = byte;
    }
}

pub fn subscribe_domain_value(domain: DomainResource, offset: u32) !void {
    const data = ecrt.ecrt_domain_data(domain.unpack());
    _ = ecrt.ecrt_domain_subscribe(domain.unpack(), offset, data[offset]);
}

pub fn domain_state(domain: DomainResource) !beam.term {
    var state: ecrt.ec_domain_state_t = undefined;
    _ = ecrt.ecrt_domain_state(domain.unpack(), &state);
    return beam.make(state, .{});
}

pub fn slave_config_sync_manager(slave_config: SlaveConfigResource, sync_index: u8, direction: ecrt.ec_direction_t, watchdog_mode: ecrt.ec_watchdog_mode_t) !void {
    _ = ecrt.ecrt_slave_config_sync_manager(slave_config.unpack(), sync_index, direction, watchdog_mode);
}

pub fn slave_config_pdo_assign_add(slave_config: SlaveConfigResource, sync_index: u8, index: u16) !void {
    _ = ecrt.ecrt_slave_config_pdo_assign_add(slave_config.unpack(), sync_index, index);
}

pub fn slave_config_pdo_assign_clear(slave_config: SlaveConfigResource, sync_index: u8) !void {
    _ = ecrt.ecrt_slave_config_pdo_assign_clear(slave_config.unpack(), sync_index);
}

pub fn slave_config_pdo_mapping_add(slave_config: SlaveConfigResource, pdo_index: u16, entry_index: u16, entry_subindex: u8, entry_bit_length: u8) !void {
    _ = ecrt.ecrt_slave_config_pdo_mapping_add(slave_config.unpack(), pdo_index, entry_index, entry_subindex, entry_bit_length);
}

pub fn slave_config_pdo_mapping_clear(slave_config: SlaveConfigResource, pdo_index: u16) !void {
    _ = ecrt.ecrt_slave_config_pdo_mapping_clear(slave_config.unpack(), pdo_index);
}

pub fn slave_config_reg_pdo_entry(slave_config: SlaveConfigResource, entry_index: u16, entry_subindex: u8, domain: DomainResource) !u32 {
    var bit_position: c_uint = 0;
    const result: c_int = ecrt.ecrt_slave_config_reg_pdo_entry(slave_config.unpack(), entry_index, entry_subindex, domain.unpack(), &bit_position);
    if (bit_position != 0) {
        std.debug.print("Bit Position: {}\n", .{bit_position});
    }
    if (result >= 0) {
        return @as(u32, @intCast(result));
    } else {
        return MasterError.PdoRegError;
    }
}

pub fn master_get_sync_manager(master: MasterResource, slave_position: u16, sync_index: u8) !beam.term {
    var sync: ecrt.ec_sync_info_t = undefined;
    _ = ecrt.ecrt_master_get_sync_manager(master.unpack(), slave_position, sync_index, &sync);
    return beam.make(.{.index = sync.index, .dir = sync.dir, .n_pdos = sync.n_pdos, .watchdog_mode = sync.watchdog_mode}, .{});
}

pub fn master_get_pdo(master: MasterResource, slave_position: u16, sync_index: u8, pos: u16) !beam.term {
    var pdo: ecrt.ec_pdo_info_t = undefined;
    _ = ecrt.ecrt_master_get_pdo(master.unpack(), slave_position, sync_index, pos, &pdo);
    return beam.make(.{.index = pdo.index, .n_entries = pdo.n_entries}, .{});
}

pub fn master_get_pdo_entry(master: MasterResource, slave_position: u16, sync_index: u8, pdo_pos: u16, entry_pos: u16) !beam.term {
    var pdo_entry: ecrt.ec_pdo_entry_info_t = undefined;
    _ = ecrt.ecrt_master_get_pdo_entry(master.unpack(), slave_position, sync_index, pdo_pos, entry_pos, &pdo_entry);
    return beam.make(pdo_entry, .{});
}

pub fn listen_bus_changes(pid: beam.pid, master_resource: MasterResource, interval: u64) !void {
    // following code triggered when process is killed.
    defer {
      beam.send(pid, .killed, .{}) catch {};
    }

    const master = master_resource.unpack();
    var state: master_state_t = try do_get_master_state(master);
    var last_state: master_state_t = undefined;

    while(true) {
        if (!std.meta.eql(master_state_t, last_state, state)) {
            _ = try beam.send(pid, .{ .master_state_changed, state }, .{});
        }
        last_state = state;
        state = tdo_get_m(stmr_stateaster);

        std.time.sleep(interval);
        try beam.yield();
    }
}
