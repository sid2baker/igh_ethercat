// this code is autogenerated, do not check it into to your code repository

// ref lib/igh_ethercat/nif.ex:47
const std = @import("std");
const beam = @import("beam");
const root = @import("root");
const ecrt = @cImport(@cInclude("ecrt.h"));

pub const MasterResource = beam.Resource(*ecrt.ec_master_t, root, .{});
pub const DomainResource = beam.Resource(*ecrt.ec_domain_t, root, .{});
pub const SlaveConfigResource = beam.Resource(*ecrt.ec_slave_config_t, root, .{});

const MasterError = error{
    MasterNotFound,
    ResetError,
    GetSlaveError,
    SlaveConfigError,
    ActivateError,
    PdoRegError,
    InvalidDomainData,
};

// this is needed since zig doesn't support bitfields. See https://github.com/ziglang/zig/issues/1499
const packed_ec_master_state_t = packed struct {
    slaves_responding: u32,
    al_states: u4,
    link_up: u1,
    padding: u27, // 27 bits to align to 64 bits (8 bytes)
};

// al_state_* turns true if at least one slave is in the specified state
const master_state_t = struct {
    slaves_responding: u32,
    al_state_init: u1,
    al_state_preop: u1,
    al_state_safeop: u1,
    al_state_op: u1,
    link_up: u1
};

const ec_slave_config_state_t = packed struct {
    online: u1,
    operational: u1,
    al_state: u4,
    padding: u2, // 2 bits to align to 8 bits (1 byte)
};

const domain_config_t = struct {
    resource: DomainResource,
    interval: u32, // multiplier for the interval
};

pub fn version_magic() !u32 {
    return ecrt.ecrt_version_magic();
}

pub fn request_master(index: u32) !beam.term {
    if (ecrt.ecrt_request_master(index)) |master| {
        const resource = try MasterResource.create(master, .{});
        return beam.make(.{ .ok, resource }, .{});
    } else {
        return beam.make_error_atom(.{});
    }
}

pub fn master_activate(master: MasterResource) !void {
    const result = ecrt.ecrt_master_activate(master.unpack());
    if (result != 0) return MasterError.ActivateError;
}

pub fn master_receive(master: MasterResource) !void {
    _ = ecrt.ecrt_master_receive(master.unpack());
}

pub fn master_send(master: MasterResource) !void {
    _ = ecrt.ecrt_master_send(master.unpack());
}

pub fn get_master_state(master: MasterResource) !beam.term {
    const master_state: master_state_t = try do_get_master_state(master.unpack());
    return beam.make(master_state, .{});
}

fn do_get_master_state(master: *ecrt.ec_master_t) !master_state_t {
    var packed_state: packed_ec_master_state_t = undefined;
    const result = ecrt.ecrt_master_state(master, @ptrCast(&packed_state));
    if (result != 0) {
        return MasterError.MasterNotFound;
    }
    return master_state_t{
        .slaves_responding = packed_state.slaves_responding,
        .al_state_init = @truncate(packed_state.al_states >> 0),
        .al_state_preop = @truncate(packed_state.al_states >> 1),
        .al_state_safeop = @truncate(packed_state.al_states >> 2),
        .al_state_op = @truncate(packed_state.al_states >> 3),
        .link_up = packed_state.link_up,
    };
}

pub fn master_create_domain(master: MasterResource) !DomainResource {
    const domain = ecrt.ecrt_master_create_domain(master.unpack()) orelse return MasterError.MasterNotFound;
    return DomainResource.create(domain, .{});
}

pub fn master_slave_config(master: MasterResource, alias: u16, position: u16, vendor_id: u32, product_code: u32) !SlaveConfigResource {
    const slave_config = ecrt.ecrt_master_slave_config(master.unpack(), alias, position, vendor_id, product_code) orelse return MasterError.SlaveConfigError;
    std.debug.print("Slave Config: {}\n", .{slave_config});
    std.debug.print("Master: {}\n", .{master.unpack()});
    return SlaveConfigResource.create(slave_config, .{});
}

pub fn master_get_slave(master: MasterResource, slave_position: u16) !beam.term {
    var slave_info: ecrt.ec_slave_info_t = undefined;
    const result = ecrt.ecrt_master_get_slave(master.unpack(), slave_position, &slave_info);
    if (result != 0) {
        return MasterError.GetSlaveError;
    }
    return beam.make(.{ .ok, slave_info }, .{});
}

pub fn master_reset(master: MasterResource) !void {
    const result = ecrt.ecrt_master_reset(master.unpack());
    if (result != 0) {
        return MasterError.ResetError;
    }
}

pub fn release_master(master: MasterResource) !void {
    // TODO check if master.release needs to be called
    ecrt.ecrt_release_master(master.unpack());
    master.release();
    std.debug.print("Master released: {}\n", .{master.unpack()});
}

pub fn domain_process(domain: DomainResource) !void {
    _ = ecrt.ecrt_domain_process(domain.unpack());
}

pub fn domain_queue(domain: DomainResource) !void {
    _ = ecrt.ecrt_domain_queue(domain.unpack());
}

// since ecrt_domain_data just returns domain->process_data
// this should be managed inside zig.
// So there should be these functions
// get_domain_value(domain, offset, bit_position?)
// which returns the current value
// set_domain_value(domain, offset, bit_position?, value)
// which sets the value
// and subscribe_domain_value(domain, offset, bit_position?)
// which subscribes to changes of the value
pub fn domain_data(domain: DomainResource) ![*c]u8 {
    const result = ecrt.ecrt_domain_data(domain.unpack());
    return result;
}

// TODO add bit_position
pub fn get_domain_value(domain: DomainResource, offset: u32) u8 {
    const data = ecrt.ecrt_domain_data(domain.unpack());
    std.debug.print("Byte 0: {}, Byte 1: {}\n", .{ data[0], data[1] });
    return data[offset];
}

// TODO handle bit precise offset
pub fn set_domain_value(domain: DomainResource, offset: u32, value: []u8) !void {
    const target: [*]u8 = ecrt.ecrt_domain_data(domain.unpack());
    for (value, 0..) |byte, i| {
        target[i + offset] = byte;
    }
}

pub fn subscribe_domain_value(domain: DomainResource, offset: u32) !void {
    const data = ecrt.ecrt_domain_data(domain.unpack());
    _ = ecrt.ecrt_domain_subscribe(domain.unpack(), offset, data[offset]);
}

pub fn domain_state(domain: DomainResource) !beam.term {
    var state: ecrt.ec_domain_state_t = undefined;
    _ = ecrt.ecrt_domain_state(domain.unpack(), &state);
    return beam.make(state, .{});
}

pub fn slave_config_sync_manager(slave_config: SlaveConfigResource, sync_index: u8, direction: ecrt.ec_direction_t, watchdog_mode: ecrt.ec_watchdog_mode_t) !void {
    _ = ecrt.ecrt_slave_config_sync_manager(slave_config.unpack(), sync_index, direction, watchdog_mode);
}

pub fn slave_config_pdo_assign_add(slave_config: SlaveConfigResource, sync_index: u8, index: u16) !void {
    _ = ecrt.ecrt_slave_config_pdo_assign_add(slave_config.unpack(), sync_index, index);
}

pub fn slave_config_pdo_assign_clear(slave_config: SlaveConfigResource, sync_index: u8) !void {
    _ = ecrt.ecrt_slave_config_pdo_assign_clear(slave_config.unpack(), sync_index);
}

pub fn slave_config_pdo_mapping_add(slave_config: SlaveConfigResource, pdo_index: u16, entry_index: u16, entry_subindex: u8, entry_bit_length: u8) !void {
    _ = ecrt.ecrt_slave_config_pdo_mapping_add(slave_config.unpack(), pdo_index, entry_index, entry_subindex, entry_bit_length);
}

pub fn slave_config_pdo_mapping_clear(slave_config: SlaveConfigResource, pdo_index: u16) !void {
    _ = ecrt.ecrt_slave_config_pdo_mapping_clear(slave_config.unpack(), pdo_index);
}

pub fn slave_config_reg_pdo_entry(slave_config: SlaveConfigResource, entry_index: u16, entry_subindex: u8, domain: DomainResource) !u32 {
    var bit_position: c_uint = 0;
    const result: c_int = ecrt.ecrt_slave_config_reg_pdo_entry(slave_config.unpack(), entry_index, entry_subindex, domain.unpack(), &bit_position);
    if (bit_position != 0) {
        std.debug.print("Bit Position: {}\n", .{bit_position});
    }
    if (result >= 0) {
        return @as(u32, @intCast(result));
    } else {
        return MasterError.PdoRegError;
    }
}

pub fn master_get_sync_manager(master: MasterResource, slave_position: u16, sync_index: u8) !beam.term {
    var sync: ecrt.ec_sync_info_t = undefined;
    _ = ecrt.ecrt_master_get_sync_manager(master.unpack(), slave_position, sync_index, &sync);
    return beam.make(.{.index = sync.index, .dir = sync.dir, .n_pdos = sync.n_pdos, .watchdog_mode = sync.watchdog_mode}, .{});
}

pub fn master_get_pdo(master: MasterResource, slave_position: u16, sync_index: u8, pos: u16) !beam.term {
    var pdo: ecrt.ec_pdo_info_t = undefined;
    _ = ecrt.ecrt_master_get_pdo(master.unpack(), slave_position, sync_index, pos, &pdo);
    return beam.make(.{.index = pdo.index, .n_entries = pdo.n_entries}, .{});
}

pub fn master_get_pdo_entry(master: MasterResource, slave_position: u16, sync_index: u8, pdo_pos: u16, entry_pos: u16) !beam.term {
    var pdo_entry: ecrt.ec_pdo_entry_info_t = undefined;
    _ = ecrt.ecrt_master_get_pdo_entry(master.unpack(), slave_position, sync_index, pdo_pos, entry_pos, &pdo_entry);
    return beam.make(pdo_entry, .{});
}

pub fn listen_bus_changes(pid: beam.pid, master_resource: MasterResource, interval: u64) !void {
    // following code triggered when process is killed.
    defer {
      beam.send(pid, .killed, .{}) catch {};
    }

    const master = master_resource.unpack();
    var state: master_state_t = try do_get_master_state(master);
    var last_state: master_state_t = undefined;

    while(true) {
        if (!std.meta.eql(last_state, state)) {
            _ = try beam.send(pid, .{ .master_state_changed, state }, .{});
        }
        last_state = state;
        state = try do_get_master_state(master);

        std.time.sleep(interval * std.time.ns_per_ms);
        try beam.yield();
    }
}

pub fn cyclic_task(master_pid: beam.pid, master_resource: MasterResource, domain_configs: []domain_config_t, interval: u32) !void {
    const master = master_resource.unpack();
    var master_state: master_state_t = undefined;
    var prev_master_state: master_state_t = undefined;

    var domains = std.ArrayList(struct {
        domain: *ecrt.ec_domain_t,
        state: ecrt.ec_domain_state_t,
        prev_data: []u8,
        data: []u8,
        interval: u32,
    }).init(beam.allocator);
    defer domains.deinit();

    for (domain_configs) |domain_config| {
        const domain = domain_config.resource.unpack();
        const size = ecrt.ecrt_domain_size(domain);
        const data_ptr = ecrt.ecrt_domain_data(domain);
        if (data_ptr == null or size == 0) {
            return MasterError.InvalidDomainData;
        }
        // Memory is handled by ecrt.h
        const data = data_ptr[0..size];
        const prev_data: []u8 = beam.allocator.alloc(u8, size) catch return error.OutOfMemory;
        @memcpy(prev_data, data);

        try domains.append(.{ .domain = domain, .state = undefined, .prev_data = prev_data, .data = data, .interval = domain_config.interval });
    }

    defer {
        beam.send(master_pid, .killed, .{}) catch {};
    }

    var counter: u32 = 0;

    while (true) {
        _ = ecrt.ecrt_master_receive(master);

        master_state = try do_get_master_state(master);
        if (!std.meta.eql(prev_master_state, master_state)) {
            _ = try beam.send(master_pid, .{ .master_state_changed, master_state }, .{});
        }

        prev_master_state = master_state;

        // Process all domains
        for (domains.items, 0..) |tuple, i| {
            const domain = tuple.domain;
            const prev_state = tuple.state;
            var state: ecrt.ec_domain_state_t = undefined;
            const prev_data = tuple.prev_data;
            const data = tuple.data;
            const interval_multiplier = tuple.interval;

            _ = ecrt.ecrt_domain_process(domain);
            _ = ecrt.ecrt_domain_state(domain, &state);

            // TODO add domain name when sending to master
            if (state.working_counter != prev_state.working_counter) {
                _ = try beam.send(master_pid, .{ .wc_changed, state.working_counter }, .{});
            }
            if (state.wc_state != prev_state.wc_state) {
                _ = try beam.send(master_pid, .{ .state_changed, state.wc_state }, .{});
            }

            if (!std.mem.eql(u8, data, prev_data)) {
                _ = try beam.send(master_pid, .{ .data_changed, data }, .{});
                @memcpy(prev_data, data);
            }

            domains.items[i] = .{ .domain = domain, .state = state, .prev_data = prev_data, .data = data, .interval = interval_multiplier};
            if (counter % interval_multiplier == 0) {
                _ = ecrt.ecrt_domain_queue(domain);
            }
        }

        _ = ecrt.ecrt_master_send(master);

        counter +%= 1; // Wraps to 0
        std.time.sleep(interval * 1_000_000);
        try beam.yield();
    }
}
