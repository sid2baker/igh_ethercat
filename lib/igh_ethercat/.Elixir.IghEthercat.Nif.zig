// this code is autogenerated, do not check it into to your code repository

// ref lib/igh_ethercat/nif.ex:49
const std = @import("std");
const beam = @import("beam");
const root = @import("root");
const ecrt = @cImport(@cInclude("ecrt.h"));

pub const MasterResource = beam.Resource(*ecrt.ec_master_t, root, .{ .Callbacks = MasterResourceCallbacks });
pub const DomainResource = beam.Resource(*ecrt.ec_domain_t, root, .{});
pub const SlaveConfigResource = beam.Resource(*ecrt.ec_slave_config_t, root, .{});

pub const MasterResourceCallbacks = struct {
    pub fn dtor(s: **ecrt.ec_master_t) void {
        std.debug.print("dtor called: {}\n", .{s.*});
        ecrt.ecrt_release_master(s.*);
    }
};

const MasterError = error{
    MasterNotFound,
    ResetError,
    GetSlaveError,
    SlaveConfigError,
    ActivateError,
    PdoRegError,
    InvalidDomainData,
};

// this is needed since zig doesn't support bitfields. See https://github.com/ziglang/zig/issues/1499
const packed_ec_master_state_t = packed struct {
    slaves_responding: u32,
    al_states: u4,
    link_up: u1,
    padding: u27, // 27 bits to align to 64 bits (8 bytes)
};

// al_state_* turns true if at least one slave is in the specified state
const master_state_t = struct {
    slaves_responding: u32,
    al_state_init: u1,
    al_state_preop: u1,
    al_state_safeop: u1,
    al_state_op: u1,
    link_up: u1
};

const ec_slave_config_state_t = packed struct {
    online: u1,
    operational: u1,
    al_state: u4,
    padding: u2, // 2 bits to align to 8 bits (1 byte)
};

const domain_config_t = struct {
    pid: beam.pid,
    resource: DomainResource,
    interval: u32, // multiplier for the interval
};

pub fn version_magic() !u32 {
    return ecrt.ecrt_version_magic();
}

pub fn request_master(index: u32) !beam.term {
    if (ecrt.ecrt_request_master(index)) |master| {
        const resource = try MasterResource.create(master, .{});
        return beam.make(.{ .ok, resource }, .{});
    } else {
        return beam.make_error_atom(.{});
    }
}

pub fn master_activate(master: MasterResource) !void {
    const result = ecrt.ecrt_master_activate(master.unpack());
    if (result != 0) return MasterError.ActivateError;
}

pub fn master_receive(master: MasterResource) !void {
    _ = ecrt.ecrt_master_receive(master.unpack());
}

pub fn master_send(master: MasterResource) !void {
    _ = ecrt.ecrt_master_send(master.unpack());
}

pub fn get_master_state(master: MasterResource) !beam.term {
    const master_state: master_state_t = try do_get_master_state(master.unpack());
    return beam.make(master_state, .{});
}

fn do_get_master_state(master: *ecrt.ec_master_t) !master_state_t {
    var packed_state: packed_ec_master_state_t = undefined;
    const result = ecrt.ecrt_master_state(master, @ptrCast(&packed_state));
    if (result != 0) {
        return MasterError.MasterNotFound;
    }
    return master_state_t{
        .slaves_responding = packed_state.slaves_responding,
        .al_state_init = @truncate(packed_state.al_states >> 0),
        .al_state_preop = @truncate(packed_state.al_states >> 1),
        .al_state_safeop = @truncate(packed_state.al_states >> 2),
        .al_state_op = @truncate(packed_state.al_states >> 3),
        .link_up = packed_state.link_up,
    };
}

pub fn master_create_domain(master: MasterResource) !DomainResource {
    const domain = ecrt.ecrt_master_create_domain(master.unpack()) orelse return MasterError.MasterNotFound;
    return DomainResource.create(domain, .{});
}

pub fn master_slave_config(master: MasterResource, alias: u16, position: u16, vendor_id: u32, product_code: u32) !SlaveConfigResource {
    const slave_config = ecrt.ecrt_master_slave_config(master.unpack(), alias, position, vendor_id, product_code) orelse return MasterError.SlaveConfigError;
    std.debug.print("Slave Config: {}\n", .{slave_config});
    std.debug.print("Master: {}\n", .{master.unpack()});
    return SlaveConfigResource.create(slave_config, .{});
}

pub fn master_get_slave(master: MasterResource, slave_position: u16) !beam.term {
    var slave_info: ecrt.ec_slave_info_t = undefined;
    const result = ecrt.ecrt_master_get_slave(master.unpack(), slave_position, &slave_info);
    if (result != 0) {
        return MasterError.GetSlaveError;
    }
    return beam.make(.{ .ok, slave_info }, .{});
}

pub fn master_reset(master: MasterResource) !void {
    const result = ecrt.ecrt_master_reset(master.unpack());
    if (result != 0) {
        return MasterError.ResetError;
    }
}

pub fn release_master(master: MasterResource) !void {
    // TODO check if master.release needs to be called
    ecrt.ecrt_release_master(master.unpack());
    master.release();
    std.debug.print("Master released: {}\n", .{master.unpack()});
}

pub fn domain_process(domain: DomainResource) !void {
    _ = ecrt.ecrt_domain_process(domain.unpack());
}

pub fn domain_queue(domain: DomainResource) !void {
    _ = ecrt.ecrt_domain_queue(domain.unpack());
}

pub fn get_domain_value_bool(domain: DomainResource, offset: usize) !bool {
    const data = ecrt.ecrt_domain_data(domain.unpack()) orelse return error.NullPointer;
    const domain_size = ecrt.ecrt_domain_size(domain.unpack());
    if (offset >= domain_size * 8) return error.OutOfBounds;
    const byte_index = offset / 8;
    const bit_index = @as(u3, @intCast(offset % 8));
    return (data[byte_index] >> bit_index) & 1 != 0;
}

// TODO handle bit precise offset
pub fn set_domain_value_bool(domain: DomainResource, offset: usize, value: bool) !void {
    const data = ecrt.ecrt_domain_data(domain.unpack()) orelse return error.NullPointer;
    const domain_size = ecrt.ecrt_domain_size(domain.unpack());
    if (offset >= domain_size * 8) return error.OutOfBounds;
    const byte_index = offset / 8;
    const bit_index = @as(u3, @intCast(offset % 8));
    if (value) {
        data[byte_index] |= (@as(u8, 1) << bit_index);
    } else {
        data[byte_index] &= ~(@as(u8, 1) << bit_index);
    }
}

pub fn domain_state(domain: DomainResource) !beam.term {
    var state: ecrt.ec_domain_state_t = undefined;
    _ = ecrt.ecrt_domain_state(domain.unpack(), &state);
    return beam.make(state, .{});
}

pub fn get_domain_size(domain: DomainResource) !usize {
    const domain_size = ecrt.ecrt_domain_size(domain.unpack());
    return domain_size;
}

pub fn slave_config_sync_manager(slave_config: SlaveConfigResource, sync_index: u8, direction: ecrt.ec_direction_t, watchdog_mode: ecrt.ec_watchdog_mode_t) !void {
    _ = ecrt.ecrt_slave_config_sync_manager(slave_config.unpack(), sync_index, direction, watchdog_mode);
}

pub fn slave_config_pdo_assign_add(slave_config: SlaveConfigResource, sync_index: u8, index: u16) !void {
    _ = ecrt.ecrt_slave_config_pdo_assign_add(slave_config.unpack(), sync_index, index);
}

pub fn slave_config_pdo_assign_clear(slave_config: SlaveConfigResource, sync_index: u8) !void {
    _ = ecrt.ecrt_slave_config_pdo_assign_clear(slave_config.unpack(), sync_index);
}

pub fn slave_config_pdo_mapping_add(slave_config: SlaveConfigResource, pdo_index: u16, entry_index: u16, entry_subindex: u8, entry_bit_length: u8) !void {
    _ = ecrt.ecrt_slave_config_pdo_mapping_add(slave_config.unpack(), pdo_index, entry_index, entry_subindex, entry_bit_length);
}

pub fn slave_config_pdo_mapping_clear(slave_config: SlaveConfigResource, pdo_index: u16) !void {
    _ = ecrt.ecrt_slave_config_pdo_mapping_clear(slave_config.unpack(), pdo_index);
}

// Returns the offset in bits
pub fn slave_config_reg_pdo_entry(slave_config: SlaveConfigResource, entry_index: u16, entry_subindex: u8, domain: DomainResource) !usize {
    var bit_position: c_uint = 0;
    const result: c_int = ecrt.ecrt_slave_config_reg_pdo_entry(slave_config.unpack(), entry_index, entry_subindex, domain.unpack(), &bit_position);
    const domain_test = get_domain_size(domain);
    std.debug.print("Domain: {any}\n", .{domain_test});
    std.debug.print("Offset: {d}, Bit Position: {d}\n", .{ result, bit_position });
    if (result >= 0) {
        return @as(usize, @intCast(result)) * 8 + bit_position;
    } else {
        return MasterError.PdoRegError;
    }
}

// Returns the offset in bits
pub fn slave_config_reg_pdo_entry_pos(slave_config: SlaveConfigResource, sync_index: u8, pdo_pos: c_uint, entry_pos: c_uint, domain: DomainResource) !usize {
    var bit_position: c_uint = 0;
    const result: c_int = ecrt.ecrt_slave_config_reg_pdo_entry_pos(slave_config.unpack(), sync_index, pdo_pos, entry_pos, domain.unpack(), &bit_position);
    if (result >= 0) {
        return @as(usize, @intCast(result)) * 8 + bit_position;
    } else {
        return MasterError.PdoRegError;
    }
}

pub fn master_get_sync_manager(master: MasterResource, slave_position: u16, sync_index: u8) !beam.term {
    var sync: ecrt.ec_sync_info_t = undefined;
    _ = ecrt.ecrt_master_get_sync_manager(master.unpack(), slave_position, sync_index, &sync);
    return beam.make(.{.index = sync.index, .dir = sync.dir, .n_pdos = sync.n_pdos, .watchdog_mode = sync.watchdog_mode}, .{});
}

pub fn master_get_pdo(master: MasterResource, slave_position: u16, sync_index: u8, pos: u16) !beam.term {
    var pdo: ecrt.ec_pdo_info_t = undefined;
    _ = ecrt.ecrt_master_get_pdo(master.unpack(), slave_position, sync_index, pos, &pdo);
    return beam.make(.{.index = pdo.index, .n_entries = pdo.n_entries}, .{});
}

pub fn master_get_pdo_entry(master: MasterResource, slave_position: u16, sync_index: u8, pdo_pos: u16, entry_pos: u16) !beam.term {
    var pdo_entry: ecrt.ec_pdo_entry_info_t = undefined;
    _ = ecrt.ecrt_master_get_pdo_entry(master.unpack(), slave_position, sync_index, pdo_pos, entry_pos, &pdo_entry);
    return beam.make(pdo_entry, .{});
}

pub fn listen_bus_changes(pid: beam.pid, master_resource: MasterResource, interval: u64) !void {
    // following code triggered when process is killed.
    defer {
      beam.send(pid, .killed, .{}) catch {};
    }

    const master = master_resource.unpack();
    var state: master_state_t = try do_get_master_state(master);
    var last_state: master_state_t = undefined;

    while(true) {
        if (!std.meta.eql(last_state, state)) {
            _ = try beam.send(pid, .{ .master_state_changed, state }, .{});
        }
        last_state = state;
        state = try do_get_master_state(master);

        std.time.sleep(interval * std.time.ns_per_ms);
        try beam.yield();
    }
}

pub fn cyclic_task(master_pid: beam.pid, master_resource: MasterResource, domain_configs: []domain_config_t, interval: u64) !void {
    const master = master_resource.unpack();
    var master_state: master_state_t = undefined;
    var prev_master_state: master_state_t = undefined;
    const yield_interval = @divTrunc(100_000, interval); // yield every 100ms

    var domains = std.ArrayList(struct {
        pid: beam.pid,
        domain: *ecrt.ec_domain_t,
        state: ecrt.ec_domain_state_t,
        prev_data: []u8,
        data: []u8,
        interval: u32,
    }).init(beam.allocator);
    defer domains.deinit();

    for (domain_configs) |domain_config| {
        const pid = domain_config.pid;
        const domain = domain_config.resource.unpack();
        const size = ecrt.ecrt_domain_size(domain);
        std.debug.print("Domain size: {}\n", .{size});
        const data_ptr = ecrt.ecrt_domain_data(domain);
        if (data_ptr == null) {
            return MasterError.InvalidDomainData;
        }
        // Memory is handled by ecrt.h
        const data = data_ptr[0..size];
        const prev_data: []u8 = beam.allocator.alloc(u8, size) catch return error.OutOfMemory;
        @memcpy(prev_data, data);

        try domains.append(.{ .pid = pid, .domain = domain, .state = undefined, .prev_data = prev_data, .data = data, .interval = domain_config.interval });
    }

    defer {
        beam.send(master_pid, .killed, .{}) catch {};
    }

    var counter: u32 = 0;
    var data_diffs = std.ArrayList(usize).init(beam.allocator);
    defer data_diffs.deinit();

    while (true) {
        _ = ecrt.ecrt_master_receive(master);

        master_state = try do_get_master_state(master);
        if (!std.meta.eql(prev_master_state, master_state)) {
            _ = try beam.send(master_pid, .{ .master_state_changed, master_state }, .{});
        }

        prev_master_state = master_state;

        // Process all domains
        for (domains.items, 0..) |tuple, i| {
            const pid = tuple.pid;
            const domain = tuple.domain;
            const prev_state = tuple.state;
            var state: ecrt.ec_domain_state_t = undefined;
            const prev_data = tuple.prev_data;
            const data = tuple.data;
            const interval_multiplier = tuple.interval;

            _ = ecrt.ecrt_domain_process(domain);
            _ = ecrt.ecrt_domain_state(domain, &state);

            if (state.working_counter != prev_state.working_counter) {
                _ = try beam.send(pid, .{ .wc_changed, state.working_counter }, .{});
            }
            if (state.wc_state != prev_state.wc_state) {
                _ = try beam.send(pid, .{ .state_changed, state.wc_state }, .{});
            }

            //std.debug.print("TEST {any}\n", .{prev_data});
            data_diffs.clearRetainingCapacity();
            for (data, prev_data, 0..) |byte_a, byte_b, byte_i| {
                const diff = byte_a ^ byte_b; // XOR to find differing bits
                if (diff != 0) {
                    var bit_mask = diff;
                    while (bit_mask != 0) {
                        const bit_pos = @ctz(bit_mask); // Find position of least significant set bit
                        try data_diffs.append(byte_i * 8 + bit_pos);
                        bit_mask &= bit_mask - 1; // Clear the least significant set bit
                    }
                }
            }

            if (data_diffs.items.len > 0) {
                @memcpy(prev_data, data);
                _ = try beam.send(pid, .{ .data_changed, data, data_diffs.items }, .{});
            }

            domains.items[i] = .{ .pid = pid, .domain = domain, .state = state, .prev_data = prev_data, .data = data, .interval = interval_multiplier};
            if (counter % interval_multiplier == 0) {
                _ = ecrt.ecrt_domain_queue(domain);
            }
        }

        _ = ecrt.ecrt_master_send(master);

        if (counter % yield_interval == 0) {
            try beam.yield();
        }

        counter +%= 1; // Wraps to 0
        std.time.sleep(interval * std.time.ns_per_us);
    }
}
